// Code generated by queryx, DO NOT EDIT.

package db

import (
	"database/sql"
	"errors"
	"fmt"
	"snap/db/queryx"
)

type DeckQuery struct {
	adapter         *queryx.Adapter
	schema          *queryx.Schema
	queries         Queries
	selectStatement *queryx.SelectStatement
	preload         map[string]bool
	err             error
}

func NewDeckQuery(adapter *queryx.Adapter, schema *queryx.Schema, queries Queries) *DeckQuery {
	s := queryx.NewSelect().Select("decks.*").From("decks")
	return &DeckQuery{
		adapter:         adapter,
		schema:          schema,
		queries:         queries,
		selectStatement: s,
		preload:         make(map[string]bool),
	}
}

func (q *DeckQuery) Create(change *queryx.DeckChange) (*Deck, error) {
	if q.err != nil {
		return nil, q.err
	}

	record := &Deck{
		schema:  q.schema,
		queries: q.queries,
	}
	now := queryx.Now("2006-01-02 15:04:05.000")
	if !change.CreatedAt.Set {
		change.SetCreatedAt(now)
	}
	if !change.UpdatedAt.Set {
		change.SetUpdatedAt(now)
	}
	columns, values := change.Changes()
	query, args := queryx.NewInsert().
		Into("decks").
		Columns(columns...).
		Values(values...).
		Returning("id,name,created_at,updated_at").ToSQL()
	err := q.adapter.QueryOne(query, args...).Scan(record)
	if err != nil {
		return nil, err
	}

	return record, nil
}

func (q *DeckQuery) InsertAll(changes []*queryx.DeckChange) (int64, error) {
	if q.err != nil {
		return 0, q.err
	}

	if len(changes) == 0 {
		return 0, ErrInsertAllEmptyChanges
	}
	now := queryx.Now("2006-01-02 15:04:05.000")
	for _, change := range changes {
		if !change.CreatedAt.Set {
			change.SetCreatedAt(now)
		}
		if !change.UpdatedAt.Set {
			change.SetUpdatedAt(now)
		}
	}

	s := queryx.NewInsert().Into("decks")
	for i, change := range changes {
		columns, values := change.Changes()
		if i == 0 {
			s.Columns(columns...)
		}
		s.Values(values...)
	}

	query, args := s.ToSQL()
	return q.adapter.Exec(query, args...)
}

func (q *DeckQuery) Delete(id int64) (int64, error) {
	query, args := queryx.NewDelete().From("decks").Where(q.schema.DeckID.EQ(id)).ToSQL()
	result, err := q.adapter.Exec(query, args...)
	if err != nil {
		return 0, err
	}
	return result, err
}

func (q *DeckQuery) Find(id int64) (*Deck, error) {
	res, err := q.Where(q.schema.DeckID.EQ(id)).First()
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, sql.ErrNoRows
	}
	res.schema = q.schema
	res.queries = q.queries
	return res, err
}

func (q *DeckQuery) FindBy(where *queryx.Clause) (*Deck, error) {
	return q.Where(where).First()
}

func (q *DeckQuery) FindBySQL(query string, args ...interface{}) ([]*Deck, error) {
	var deckList []Deck
	decks := make([]*Deck, 0)
	err := q.adapter.Query(query, args...).Scan(&deckList)
	if err != nil {
		return nil, err
	}
	for i := 0; i < len(deckList); i++ {
		decks = append(decks, &deckList[i])
	}
	return decks, nil
}

func (q *DeckQuery) Where(clause *queryx.Clause) *DeckQuery {
	q.selectStatement.Where(clause)
	q.err = clause.Err()
	return q
}

func (q *DeckQuery) Select(selection ...string) *DeckQuery {
	q.selectStatement.Select(selection...)
	return q
}

func (q *DeckQuery) Limit(limit int) *DeckQuery {
	q.selectStatement.Limit(limit)
	return q
}

func (q *DeckQuery) Offset(offset int) *DeckQuery {
	q.selectStatement.Offset(offset)
	return q
}

func (q *DeckQuery) Group(group string) *DeckQuery {
	q.selectStatement.GroupBy(group)
	return q
}

func (q *DeckQuery) Having(having string) *DeckQuery {
	q.selectStatement.Having(having)
	return q
}

func (q *DeckQuery) Joins(joins string) *DeckQuery {
	q.selectStatement.Join(joins)
	return q
}

func (q *DeckQuery) Order(order ...string) *DeckQuery {
	q.selectStatement.Order(order...)
	return q
}

func (q *DeckQuery) PreloadDeckCards() *DeckQuery {
	q.preload["deck_cards"] = true
	return q
}

func (q *DeckQuery) preloadDeckCards(rows []*Deck) error {
	ids := []int64{}
	for _, r := range rows {
		ids = append(ids, r.ID)
	}
	rows1, err := q.queries.QueryDeckCard().Where(q.schema.DeckCardDeckID.In(ids)).All()
	if err != nil {
		return err
	}

	m := make(map[int64][]*DeckCard)
	for _, r := range rows1 {
		m[r.DeckID.Val] = append(m[r.DeckID.Val], r)
	}
	for _, r := range rows {
		if m[r.ID] != nil {
			r.DeckCards = m[r.ID]
		} else {
			r.DeckCards = make([]*DeckCard, 0)
		}
	}

	return nil
}

func (q *DeckQuery) PreloadCards() *DeckQuery {
	q.preload["cards"] = true
	return q
}

func (q *DeckQuery) preloadCards(rows []*Deck) error {
	ids := []int64{}
	for _, r := range rows {
		ids = append(ids, r.ID)
	}
	rows1, err := q.queries.QueryDeckCard().Where(q.schema.DeckCardDeckID.In(ids)).All()
	if err != nil {
		return err
	}
	m1 := make(map[int64][]*DeckCard)
	for _, r := range rows1 {
		m1[r.DeckID.Val] = append(m1[r.DeckID.Val], r)
	}
	for _, r := range rows {
		if m1[r.ID] != nil {
			r.DeckCards = m1[r.ID]
		} else {
			r.DeckCards = make([]*DeckCard, 0)
		}
	}

	ids1 := []int64{}
	for _, r := range rows1 {
		ids1 = append(ids1, r.CardID.Val)
	}
	rows2, err := q.queries.QueryCard().Where(q.schema.CardID.In(ids1)).All()
	if err != nil {
		return err
	}
	m2 := make(map[int64]*Card)
	for _, r := range rows2 {
		m2[r.ID] = r
	}
	for _, r := range rows1 {
		r.Card = m2[r.CardID.Val]
	}

	m3 := make(map[int64][]*Card)
	for _, r := range rows1 {
		m3[r.DeckID.Val] = append(m3[r.DeckID.Val], r.Card)
	}
	for _, r := range rows {
		if m3[r.ID] != nil {
			r.Cards = m3[r.ID]
		} else {
			r.Cards = make([]*Card, 0)
		}
	}

	return nil
}

func (q *DeckQuery) All() ([]*Deck, error) {
	if q.err != nil {
		return nil, q.err
	}
	var rows []Deck
	decks := make([]*Deck, 0)
	query, args := q.selectStatement.ToSQL()
	err := q.adapter.Query(query, args...).Scan(&rows)
	if err != nil {
		return nil, err
	}

	if len(rows) == 0 {
		return decks, nil
	}

	for i := range rows {
		rows[i].schema = q.schema
		rows[i].queries = q.queries
		decks = append(decks, &rows[i])
	}
	if q.preload["deck_cards"] {
		if err := q.preloadDeckCards(decks); err != nil {
			return nil, err
		}
	}
	if q.preload["cards"] {
		if err := q.preloadCards(decks); err != nil {
			return nil, err
		}
	}

	return decks, nil
}

func (q *DeckQuery) First() (*Deck, error) {
	q.Limit(1)
	results, err := q.All()
	if err != nil {
		return nil, err
	}
	if len(results) > 0 {
		return results[0], nil
	}

	return nil, nil
}

func (q *DeckQuery) Count() (int64, error) {
	var res struct {
		Count int64 `db:"count"`
	}
	q.selectStatement.Select("count(*)")
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Count, nil
}

func (q *DeckQuery) Avg(v string) (float64, error) {
	var res struct {
		Avg sql.NullFloat64 `db:"avg"`
	}
	q.selectStatement.Select(fmt.Sprintf("avg(%+v)", v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Avg.Float64, nil
}

func (q *DeckQuery) Sum(v string) (float64, error) {
	var res struct {
		Sum sql.NullFloat64 `db:"sum"`
	}
	q.selectStatement.Select(fmt.Sprintf("sum(%+v)", v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Sum.Float64, nil
}

func (q *DeckQuery) Max(v string) (float64, error) {
	var res struct {
		Max sql.NullFloat64 `db:"max"`
	}
	q.selectStatement.Select(fmt.Sprintf("max(%+v)", v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Max.Float64, nil
}

func (q *DeckQuery) Min(v string) (float64, error) {
	var res struct {
		Min sql.NullFloat64 `db:"min"`
	}
	q.selectStatement.Select(fmt.Sprintf("min(%+v)", v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Min.Float64, nil
}

func (q *DeckQuery) Exists() (bool, error) {
	q.selectStatement.Select("1 AS one").Limit(1)
	// select 1 as one from users limit 1
	query, args := q.selectStatement.ToSQL()
	var res struct {
		One int64 `db:"one"`
	}
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, err
	}

	return res.One == 1, nil
}

func (q *DeckQuery) UpdateAll(change *queryx.DeckChange) (int64, error) {
	if q.err != nil {
		return 0, q.err
	}
	now := queryx.Now("2006-01-02 15:04:05.000")
	if !change.UpdatedAt.Set {
		change.SetUpdatedAt(now)
	}
	columns, values := change.Changes()
	query, args := q.selectStatement.Update().Columns(columns...).Values(values...).ToSQL()
	result, err := q.adapter.Exec(query, args...)
	if err != nil {
		return 0, err
	}
	return result, err
}

func (q *DeckQuery) DeleteAll() (int64, error) {
	query, args := q.selectStatement.Delete().ToSQL()
	result, err := q.adapter.Exec(query, args...)
	if err != nil {
		return 0, err
	}
	return result, err
}
